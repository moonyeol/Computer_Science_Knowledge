# 안드로이드 개념 정리

### 안드로이드 4대 컴포넌트

액티비티 : 안드로이드에서 화면을 관리하고 사용자의 다양한 이벤트를 처리하는데 사용됩니다.

서비스 : 화면에서 보이지 않지만 특정한 기능르 백그라운드에서 처리하는데 사용됩니다.

브로드캐스트 리시버 : 안드로이드에서 발생하는 특정 브로드캐스트 메시지를 처리하기 위한 컴포넌트입니다.

콘텐트 프로바이더 : 앱 사이의 데이터의 공유를 위한 인터페이스를 제공하는 컴포넌트입니다.



### 안드로이드 액티비티와 액티비티의 수명주기에 대해 설명해보세요

안드로이드에서 화면을 관리하며 사용자가 발생시키는 다양한 이벤트를 처리하는 컴포넌트입니다.

부모 액티비티에서 새로운 자식 액티비티를 실행하고자 한다면 먼저 매니페스트 파일에 해당 자식 액티비티를 추가해 줘야합니다. 다음으로, 부모 액티비티에서 startActivity 메소드에 인텐트를 파라미터로 넘겨 실행하거나 startActivities 메소를 이용하여 여러 개의 액티비티를 실행할 수 있습니다.

액티비티의 실행과정은 첫 번째로, 부모 액티비티에서 자식 액티비티를 생성 및 호출합니다. 두 번째로, 액티비티 매니저 서비스가 해당 앱 프로세스에서 인텐트를 복사해온 후, 매니페스트 파일에서 해당 인텐트에 명시되어 있는 액티비티를 찾고 어떻게 실행시켜야할지 결정합니다. 세 번째로, 찾아낸 액티비티를 실행하고 다시 해당 앱 프로세스를 복사해서 넘겨줍니다. 그 외 자식 액티비티 내의 onCreat 메소드에서 setContentView 메소드에 레이아웃의 아이디를 파라미터로 넘겨 해당 액티비티의 화면을 구성하게 됩니다.

액티비티는 크게 3가지 상태가 존재합니다. 먼저, 실행(running)상태는 액티비티 스택의 최상위에 있으며 포커를 가지고 있어 사용자에게 보이는 상태입니다. 다음으로 일시 중지(paused)상태는 사용자에게 보이기는 하지만 다른 액티비티가 위에 있어서 포커스를 받지 못하는 상태를 말합니다. 예를 들어, 대화상자가 위에 있어 일부가 가려져 있는 경우를 말합니다. 마지막으로 중지 상태는 다른 액티비티에 의해 완전히 가려져서 보이지 않는 상태를 말합니다.

액티비티가 처음만들어지면 onCreate 메소드가 호출되서 레이아웃을 구섭합니다. 이후, onStart메소드가 화면에 보이기 직전에 호출됩니다. onResume 메소드가 사용자 상호작용(화면이 포커스를 얻었을 때)하기 바로 전에 호출됩니다. 이 3가지 메소드가 호출되면 액티비티는 실행 상태를 갖게됩니다. 이후 포커스를 잃었을 때, onPause 메소드가 호출되고 일시중지 상태가 됩니다. 일시중지 상태에서 다시 포커스를 획득하면 onResume 메소드가 호출되거나 다른 액티비티에 의해서 완전히 화면이 가려졌는지 여부를 확인하여 가려져 보이지 않은 경우, onStop메소드가 호출되어 중지 상태가 됩니다. 정지 상태에서 다시 화면이 보이기 직전에 onRestart메소드가 호출되고 onStart메소드가 차례로 호출됩니다. 그 외 finish 메소드가 실행되어 해당 액티비티가 종료되기 직전에 onDestroy메소드가 실행됩니다.

가끔은 일시중지나 중지상태에서 시스템이 메모리가 부족하다고 판단될 경우, onCreate 메소드부터 다시 해당 액티비티를 구동합니다. onStop, onResume메소드 호출이 생략됩니다. 따라서 onSaveInstanceState, onRestoreInstanceState 메소드를 이용해 액티비티가 갑자기 죽을 것을 대비해서 상태를 저장하고 복원하기 위한 작업을 정의해 줄 수 있습니다.



### 프래그먼트의 생명주기에 대해서 설명하세요.

onAttach함수가 onCreat이전에 호출됩니다. 그 이후 onCreate 함수가 호출되고, onCreateView에서 LayouyInflater로 UI관련 작업을 할 수 있습니다. 그리고 화면이 포커스를 잃었을 때는 onPause onStop onDestoryView가 호출되고 종료시에 onDestroy onDetach()가 호출됩니다.



### 안드로이드의 매니페스트 파일에 대해서 설명해보세요.

 매니페스트 파일은 앱의 이름, 버전, 구성요소, 권한 등 앱의 실행에서 꼭 필요한 정보가 저장되어 있는 파일입니다. xml파일로 프로젝트 최상위에 존재합니다.

태그 구성으로 가장 위는 manifest태그가 존재하고 패키지명, 버전 등이 기재됩니다.

application태그에는 앱 아이콘, 앱 이름 등의 정보가 저장됩니다.

activity태그에는 액티비티 클래스명과 액티비티 이름을 정의합니다.

activity하위에는 intent-filter태그를 이용해서 액티비티에 대한 인텐트 작업시 필요한 action과 category를 정의합니다.

service, reciver,provider태그에는 서비스, 리시버, 프로바이더에 대한 내용이 정의되어 있습니다.

permission 태그에는 앱에서 필요한 권한을 정의합니다.

그밖에 sdk버전을 지칭하는 uses-sdk와 다른 패키지를 등록할 수 있는 uses-library등이 존재합니다.

​    

### 안드로이드 인플레이션에 대해 설명해보세요

### webview란

안드로이드 프레임워크에 내장된 컴포넌트로 view형태로 임베딩할 수 있는 형태이다.

웹페이지를 보거나 안드로이드 앱 안에서 html을 호출하여 앱을 구현하는 하이브리드 앱을 개발하는데에도 많이 사용된다.



### rxjava란?

Reactive programming을 기반으로한 언어입니다.

즉 Reactive Extension의 JVM버전입니다.

비동기 데이터처리를 효율적으로 할 수 있는 장점이 있습니다,



### Reactive Programming은?

컴퓨팅으로써 반응형 프로그래밍은 데이터의 흐름과 변화에 대한 전달을 기반을 h하는 프로그래밍 패러다임이다. 끊임없이 요청/변경되는 데이터에 반응하기 위해 나온 Reactive Programming은 데이터를 처리함에 있어서 비동기적으로 데이터를 처리할 때 효율적으로 할 수 있도록 하기 위한 방법입니다.

반응형 프로그래밍의 특징

for if while 같은 것이 아니라 sql쿼리 같은 선언형으로 구성됩니다.

또 함수를 단지 호출하는 대상이 아니라 변수로도 혹은 인자로도 넘길 수 있습니다.

이러한 함수형언어의 도구들을 자유롭게 활용해양 합니다.(자바의 람다표현식)



### 코틀린의 장점

기존의 자바 코드의 보일러 플레이트 구문을 최소화 시킬 수 있습니다.

기존의 자바에서도 람다표현식을 이용하여 코드의 간소화를 위해 노력했습니다.

java8에서는 라이브러리를 사용하지 않고 람다표현식이 가능합니다.

하지만 안드로이드 스튜디오 2.4 이상부터 jdk 1.8로 빌드가 가능하고 minsdk도 24이기 때문에 실질적으로 사용하지 못하는 것으로 알고있습니다. 즉 j아1.6기반의 api와 문법적으로 조금 추가된 형태로 빌드 할수 있다고 봅니다.

안드로이드의 대표적인 보일러 플레이트 구문은 레이아웃에 정의한 뷰 레퍼런스를 가지고 오는 부분이나 sqlite트랜잭션을 처리하는 부분이 있습니다.

또 자바8의 스트림 api를 사용할 수도 없습니다.

스트림에 대한 대비로는 streamsupport, Lightweight-Stream-Api가 있습니다.

RxJava또한 자바8 스트림의 훌륭한 대안이고 안드로이드 커뮤니티에서 많이 쓰이고 있습니다.

하지만 위의 라이브러리들의 의존성문제와 기존 라이브러리에 대한 학습 등이 부담으로 다가온다는 사실이 있습니다.

코틀린의 좋은점으로는 NullPointException 다루기, 보일러 플레이트 개선하기, Collection에 filter, map, foreach 같은 고차 함수를 적용할 수 있고, 변경학능한 컬렉션과 불가능한 컬렉션을 엄격히 구분합니다, 서버에서 수신받은 데이터를 컬렉션으로 다룰 일이 많기 때문에 코드를 보다 간결하고 안전하게 만드는 데 도움이 됩니다. 또, 확장함수라는 강력한 기능도 있습니다.

자바와 호완성이 좋고 기존라이브러리를 제약없이 사용할 수 있습니다.

새로운 언어를 배워야한다는 부담감과 기술적이슈가 발생했을 때 대응기간이 상대적으로 길어질 수 있다는 단점도 있습니다.



### 안드로이드의 테스크란?

task는 어플에서 실행되는 액티비티를 관리하는 스택입니다. 후입선출 형태로 나중에 적재된 액티비가 가장 먼저 사용됩니다. 최초로 적재된 액티비티는 root 액티비티라고 하면 마지막에 적재된 액티비티는 탑 액티비티라고 합니다.

flag를 이용하여 액티비티의 흐름을 제어 할 수 있습니다.

 

### Realm이란?

sqlite,realm은 안드로이드 단말에서 사용하는 관계형 데이터베이스입니다.

sqlite는 오픈소스 데이터베이스로 os와 상호작용하기 위해 sqliteOpenHelper인터페이스를 이용합니다. sqlite는 c언어로 되어있고 경량데이터베이스이며 하나의 디스크 파일에 모든 데이터를 저장할 수 있습니다.

Realm은 크로스 플랫폼 기반의 모바일 데이터베이스입니다. ios와 android 모두 사용이 가능하며 성능 및 효율성이 우수합니다. 설치도 간편하며 쿼리 응답속도도 기타 ORMLite나 SQLite보다 더 좋습니다. 크로스 플랫폼이기 때문에 협업에서 유용합니다.

특징으로는 zero-copy모델을 사용하기 때문에 데이터 객체 자체에서 그대로 작업이 가능합니다. 크로스 플랫폼이기 때문에 특정 os를 가리지 않고 동기화 될수 있습니다.

ACID를 준수합니다.

Realm은 데이터베이스 컨테이너의 인스턴스입니다.

Sqlite 기반의 ORM 프레임워크입니다.



###   RestAPI란? (Representation State Transfer)

웹상에 존재하는 모든 자원에 URI를 부여하여 사용하는 방법입니다. (비연결성, URI로 자원에 접근) HTTP웹표준을 이용하여 HTTP의 캐싱을 활용할 수 있다는 장점이있스빈다. 그리고 구조가 명확하여 클라이언트와 서버에서 개발해야할 부분이 명확해지고 URI만 봐도 어떤 요청인지 파악될 수 있게 직관적이다 라는 특징이 있습니다.



### 하이브리드 앱이란?

네이티브 앱처럼 하드웨어 기능들을 사용할 수 있으며 마켓에 등록이 가능하며 배포후에도 웹만 연결되어 있다면 수정/보완을 할수 잇스빈다. 또한, 하나의 소스로 아이폰과 안드로이드에 맞게 포장이 가능하며 핵심 부분은 웹 앱 기술로 빠르게 제작이 가능하여 개발 비용이 적어질수 있습니다.

실제 핵심기능은 코드로 구현하고 지속적으로 업데이트 할 부분은 웹에서 관리하는 기능입니다.



### FCM의 구동 원리? (Firebase Cloud Messaging의 약자)

본연의 서버의 기능을 수행하면서 또 하나의 복잡한 알림 기능까지 포함한다면 서버의 속도는 처리량이 많아 느려질 것이다. 따라서 이러한 해결책으로 알림의 기능은 다른 서버가 제공을 해주고 본 서버는 알림기능을 제공하는 서버에 알림이 있는지 요청을 해서 정보를 가져오는 구조이다.

FCM의 동작을 위해서 HTTP나 XMPP로 FCM과 통신하는 서버와 클라이언트 앱이 필요합니다.

동작 순서

디바이스에 앱이 설치된후 최초 실행되면서 고유 식별자인 디바이스 토큰이 발급된다. 이 토큰을 앱 서버에 등록한다.

앱 서버에서 FCM 연결 서버로 푸시 알림을 요청한다. 이때 준비물은 디바이스 토큰과 API 서버 키이다.

FCM 연결 서버는 토큰을 대상으로 알림 메시지를 푸시한다.

​    