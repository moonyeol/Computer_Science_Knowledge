---
layout: post
title: 리눅스
subtitle: 리눅스란, 명령어, 쉘 프로그래밍
gh-repo: 
gh-badge: [star, fork, follow]
tags: 운영체제
categories : OS
comments: true

---

### 운영체제란? 

운영체제(Operating System)란 하드웨어 자원들(cpu, memory, disk, tty ...)을 관리하고 프로그램들을 지원(support) 해주는 것입니다.

 

​                                 

### 리눅스란?

리눅스는 핀란드의 리누스 토발즈(Linus Torvalds)에 의해 1991년 탄생했으며처음엔 인텔 CPU (80386)를 장착한 피시용으로 개발되었습니다.

리눅스는 멀티유저, 멀티태스킹을 지원하는 유닉스처럼 보이는 운영체제입니다.

하지만 리눅스는 유닉스와는 독립적으로 개발되었으므로 유닉스계열 운영체제가 아니라 유닉스 클론(Clone)의 운영체제 입니다.

리눅스의 소스코드는 일반 공용 라이센스(GNU; General Public License)에 따라 공개되어 있어 누구나 사용할 수 있습니다.

공식 사이트([http://www.kernel.org](http://www.kernel.org/))에서 다운로드 가능합니다.

 

### 장점

- 오픈소스

- 모든 구성 요소를 완전히 재구성 가능하다.

- 성능이 좋지 않은 하드웨어 플랫폼에서도 동작한다.

- 리눅스 개발자들은 훌륭한 프로그래머들이다.

- 커널을 매우 작고 아담하게 만들 수 있다.

- 여러 대중적인 운영체제와 호환이 잘 된다.

- 지원이 잘 된다.

- 커뮤니티가 많다.

 

### 특징

**모놀리식** **커널**

​	Q) **모놀리식** **커널** **(Monolithic Kernel)**

​		운영 체제에서 모놀리식 커널(Monolithic kernel)은 커널의 구조 및 설계 사상을 말합니다. 단일형 커널이라고도 합니다.

​		입출력 기능, 네트워크 기능, 장치 지원 등 운영 체제의 일반적인 기능을 커널과 동일한 메모리 공간에 적재, 실행하는 기법을 말합니		다.

 		커널이 모든 시스템 서비스들을 관리하기 때문에 개발자는 커널이 제공하는 함수만 사용해서 쉽게 사용 할 수 있습니다. 대표적으로 		Linux, Unix가 있습니다.

​		(커널에 넣는 기능에 따라 모놀리식과 마이크로 커널로 나뉜다.)

​	Q) **마이크로** **커널** **(Microkernel)**

​		기능이 최소화 된 커널. 가장 핵심적인 기능만 커널에 담고 나머지는 제외해서 가볍게 만든 실시간성을 목적으로 만든 커널.

​		기존에 모놀리식 커널이 갖고 있었던 기능(VFS, IPC, Device Driver 등)은 커널 위의 서버(제공자?) 형태로 존재합니다. 이로 인해 특정 		기능의 서버가 다운되어도 다른 서버는 정상 동작이 가능합니다.

​		실시간성이 중요한 임베디드 시스템에서 주로 사용됩니다. 대표적으로 MacOS X, Windows NT가 있습니다.

​		→ 리눅스는 마이크로 커널의 장점을 취하기위해 '모듈' 기능 제공.

​		리눅스는 운영체제를 구성하는 컴포넌트 들을 필요로 할 때 동적으로 로드 또는 언로드할 수 있게 합니다. 리눅스 모듈은 시스템이 부		팅된 후 언제라도 커널에 동적으로 링크될 수 있습니다. 또한, 모듈이 더이상 필요하지 않을 때는 커널과의 연결을 해제하고 제거할 		수 있습니다.    

​		- 실행 중 커널에 링크/언링크 할 수 있는 오브젝트 파일

​		- 오브젝트 파일은 기능을 구현하는 함수의 집합

​		- 모듈화된 접근 가능

​		- 플랫폼에 독립적이고, 필요할 때 링크/언링크 가능하여 메모리를 적게 사용

 

**컴파일한** **후** **정적으로** **링크된** **전통적인** **유닉스** **커널**

동적인 커널 코드의 일부를 필요할 때 로드/언로드 할 수 있습니다. (모듈 개념, 여기서 동적 커널 코드는 대부분 장치 드라이버)

​		Q) **적재** **가능** **커널** **모듈** **(LKM; Loadable Kernel Module)**

​		운영체제에서 실행 중인 커널을 확장하는 코드를 포함하는 파일입니다. 일반적으로 새로운 하드웨어나 파일 시스템을 위한 지원 또는 		시스템 호출을 추가하는데 사용합니다. LKM에 의해 제공되는 기능이 더 이상 요구되지 않으면 메모리와 자원을 해제하기 위해 언로		드 시킬 수 있습니다.

​		적재 가능 커널 모듈 없이는 운영체제에서 모든 기능을 직접 기본 커널에 포함시켜야 합니다. 사용되지 않는 동안에도 메모리에 상주		함으로써 메모리를 낭비하고 부팅 시간을 늘립니다.

 

**커널** **스레드**

독립적으로 스케줄링 할 수 있는 일종의 실행 컨텍스트(Execution Context)로서, 커널의 기능 중 몇 가지를 주기적으로 실행하는 제한된 목적으로만 커널 스레드를 사용합니다.

커널 스레드의 역할은 백그라운드에서 여러 작업들(Swap, Scheduling 등)을 커널 모드로 동작시키는 것입니다. 커널이 스레드의 생성 및 스케줄링 등을 관리합니다. 데몬처럼 메모리에 상주합니다.

예를 들어, fork를 호출하면 Context Switching이 일어나고 이에 따라 데이터를 복사하는 등의 작업으로 리소스 사용이 발생합니다. 하지만 커널 스레드는 커널 모드에서만 동작하기 때문에 Context Switching을 할 필요가 없으며 그에 따라 리소스 사용이 현저하게 줄어드는 이점이 있습니다.

 

**멀티** **스레드** **애플리케이션** **지원**

멀티 스레드 애플리케이션을 지원합니다. 리눅스는 경량 프로세스를 기본적인 실행 컨텍스트로 여기고 clone() 시스템 콜을 통해 다룹니다.

리눅스는 스케줄러가 스레드를 스케줄하며, 이 스레드는 "경량 프로세스"로 간주됩니다. 모든 스레드를 범위가 PTHREAD_SCOPE_SYSTEM인 프로세스처럼 예약합니다.

 

**선점형** **커널**

"Preemptible Kernel" 옵션으로 컴파일 한 리눅스 커널은 특권 모드(Privileged Mode)로 동작중인 시스템 흐름에 마음대로 끼어들 수 있습니다.

 

**멀티** **프로세서** **지원**

여러 프로세서를 사용할 수 있고, 모든 프로세서가 동등하게 어떤 작업이든 가능합니다.

 

**파일** **시스템**

Ext2 Ext3, Ex4, JFS(Journalling) 같은 파일 시스템 사용.

 

**파일명**

파일명은 /를 제외한 거의 모든 문자를 사용할 수 있습니다.

- 파일명은 대소문자를 구분

- 밑줄 문자를 사용하는 것이 좋다.

- 점(.)문자로 시작하는 파일을 설정파일이며 감춰진 파일

 

**파일명** **확장자**

- Unix에는 파일확장자라는 개념이 없다.

- .은 특별한 의미가 없으며, 확장자의 길이도 제약이 없다.

- 일부 프로그램은 한 글자짜리 확장자를 이용해 파일의 종류를 인식하기도 한다.

- 파일의 내용이 무엇인지 쉽게 알아볼 수 있도록 임의의 확장자를 붙이기도 한다.



**다중사용자** **시스템**

다중사용자 시스템은 도이에 여러 개의 프로그램을 실행할 수 있고, 한 프로그램이 끝나길 기다렸다가 다음 프로그램을 실행시킬 필요도 없습니다. 백그라운드 모드로 작업을 실행할 수 있습니다.

만약, C프로그램을 컴파일하는 동안 vi를 이용해 다른 코드를 작성하고 싶다면 아래와 같이 명령행에 입력해주면 됩니다.

~~~~    ~~~
$ gcc -O bigprogram.c &
[1] 2236
$ vi code.py 
~~~~

문자 &가 의미하는 것은 이 작업을 백그라운드에서 실행하라는 뜻입니다. 그 다음 [1]은 쉘 상의 작업제어를 위한 작업번호이며, 2236은 프로세스 ID를 의미합니다.

 

**백그라운드** **프로세싱**

- 작업을 백그라운드로 돌려야 하는데 깜빡잊고 실수했다면 CTRL-z를 눌러 작업을 중지시킨 후 bg 명령어를 입력하여 백그라운드에서 재시작시킬 수 있다.

~~~ ~~~
  $ find /usr -name -print > mine
  CTRL-z
  Stopped
  %bg
  [1] find /usr -name -print > mine  
~~~

- 백그라운드에서 실행되고 있는 파일을 포어그라운드로 올리려면 fg명령을 이용한다.

- 백그라운드에서 여러개의 작업이 실행되고 있다면 jobs명령어로 그 목록을 불러올 수 있다.

~~~ ~~~
 $ sleep 3; ls  &   #3초 뒤에 ls가 백그라운드에서 실행된다.
 $ (sleep 3; ls) &  #전체 백그라운드에서 실행된다.
~~~

- vi 와 같은 편집기는 백그라운드에서 실행이 되지 않는다. 그러나 실행중인 vi를 백그라운드로 중지시키는 경우는 있다.

 

**작업** **제어** **요약**

| **명령어**  | **의미**                                                     |
| ----------- | ------------------------------------------------------------ |
| command &   | 백그라운드에서 command를 실행. 계속해서 포그라운드에서 다른 작업들을 실행할 수 있음 |
| CTRL+c      | INTR 시그널을 보내서 포그라운드 작업을 죽임                  |
| CTRL+z      | TSTP 시그널을 보내서 포그라운드 작업을 중지시킴              |
| suspend     | 쉘을 중지시킴                                                |
| stop        | 명령어 또는 같은 기능의 앨리어스를 이용해 백그라운드 작업을 중지시킴 |
| bg %num     | 중지된 작업을 백그라운드에서 계속 실행되도록 함              |
| fg %num     | 백그라운드 작업이나 중지된 작업을 포그라운드로 가져옴        |
| kill &num   | 특정 백그라운드 작업을 중지시킴                              |
| kill pid    | 프로세스 ID를 이용해 특정 백그라운드 작업을 종료시킴         |
| jobs        | 백그라운드 작업과 중지된 작업을 작업 번호와 함께 나열함      |
| set notify  | 작업의 상태가 바뀌면 즉시 통보함                             |
| stty tostop | 백그라운드 작업들이 화면에 메세지를 출력하지 못하도록 함     |

 

 

### 명령어

**리눅스** **기초** **명령어**

- pwd

  pwd는 Print Work Directory의 약자이며, 현재 작업 중인 디렉터리를 보여줍니다. 이것은 현재 사용자가 있는 디렉터리를 보여줍니다.

- ls

  ls 명령 list segments의 약자이며, 아마도 유닉스 세계에서 가장 널리 사용되는 명령 중 하나일 것입니다. 파일과 디렉터리의 모든 정보를 제공하며 특정 디렉터리와 특정 파일의 내용도 제공합니다.

- cd

  리눅스에서 작업하고 있는 현재의 위치를 현재 디렉토리라고 합니다.

  파일 또는 디렉터리의 이름을 절대 경로로 지정하지 않으면 현재 디렉터리를 기준으로 상대적인 위치에서 파일을 찾습니다. 시스템에 로그인하면 홈 디렉터리가 현재 디렉터리가 됩니다. 이에 해당 디렉터리로 이동하는 방법이 cd 명령어입니다.

- mkdir

  Windows os에서 문서 또는 이미지 파일 등을 정리하기 위해 새 폴더를 만드는 것과 같이 리눅스에서도 새 디렉터리를 만듭니다. mkdir 명령은 필요한 권한을 가지고 있다면 Linux 시스템에서 원하는 위치에 폴더를 만들 수 있습니다.

- rm

  리눅스 명령어 rm은 Remove의 약어로, 하나 이상의 파일을 삭제할 때 사용하거나 디렉토리를 삭제할 때 사용합니다. 별도의 별도의 옵션을 주지 않을 경우 파일만 삭제가능하며, 옵션을 주었을 경우 디렉토리는 삭제 가능합니다.

- rmdir

  rmdir은 remove directory의 약자이며, 빈 디렉터리를 삭제할 때 사용하는 명령어입니다. 삭제하려는 디렉터리가 비어있지 않을 경우에는 삭제를 할 수 없습니다.

- lsblk

  Linux 시스템에서 사용 가능한 블록 장치를 나열해야 할 경우가 종종 잇습니다. lsblk는 이 목적으로 가장 많이 사용되는 Linux 명령어 중 하나입니다. 이 명령어는 블록 장치의 트리 구조를 나타냅니다.

- mount

  Windows와 달리 SD 카드 또는 USB를 연결할 때마다 배포판이 처음에 직접 표시되지 않을 가능성이 존재합니다. mount 명령어를 사용하여 기존 파일 시스템으로 마운트 해야 합니다.

- df

  df 명령은 파일 시스템의 디스크 공간에 대한 필수 정보를 표시하는 Linux 터미널 명령 중 하나입니다. 시스템 관리자가 실시간 서버 또는 네트워크 지향 시스템을 모니터링하고 분석하는 데 널리 사용됩니다.

  기본적으로 1024Byte 블록 단위로 출력하며, 옵션을 통해서 다른 단위로도 출력이 가능합니다.

 

**시스템** **조작을** **위한** **리눅스** **명령어**

- uname

  uname 명령은 이름, 버전 및 기타 시스템 특정 세부 사항과 같은 시스템 정보를 얻기 위한 기본 Linux 명령어입니다. 이 명령으로 OS 및 커널 버전을 빠르게 확인할 수 있으며, 명령 길이를 확인할 수 있습니다.

- ps

  이 리눅스 명령어는 현재 시스템에서 실행 중인 프로세스를 시각화할 수 있습니다.

  시스템 리소스를 분석하는데 사용되는 매우 유연한 수단이며, 터미널을 통해 기본적으로 시스템 프로세스를 조작할 수도 있습니다. 이 리눅스 명령어는 기본 및 최상의 Linux 모니터링 도구 중 하나로 간주됩니다.

- kill

  프로세스를 죽일 때(종료시킬 때) 사용합니다. kill은 자원 제한으로 인해 멈춘 프로세스를 중지하는 명령어입니다. 하지만 내부적으로는 프로세스에 시그널을 보내 원하는 작업을 하게 하는 명령어입니다.

- service

  service 명령어는 시스템 서비스를 조작하기 위한 명령어입니다. 시스템 서비스 명령어는 리눅스 '**/etc/init.d**' 디렉토리에 있는 링크파일들 중에 시작이나 종료, 재시작을 선택할 수 있습니다.

  '**/etc/init.d**' 디렉토리에는 리눅스에서 사용할 수 있는 프로그램 실행파일의 링크파일이 위치하는 곳으로 'service' 명령어를 사용하여 해당 프로그램을 시작하거나, 종류, 재시작을 명령할 수 있습니다. 이 때, service 명령어와 함께 옵션을 부여하여 프로그램의 상태를 조절합니다.

- batch

  시스템 부하가 일정 이하가 되면 예약 명령을 실행한다.(load average <= 0.8)

- shutdown

  리눅스 명령어 shut down은 halt, init과 함께 시스템을 종료하는 명령어 중 하나입니다. shut down은 현재 접속 중인 모든 사용자에게 시스템이 종료된다는 메시지를 보낼 수 있습니다.

**파일** **관리를** **위한** **리눅스** **명령어**

- touch

  touch 명령은 유효한 빈 파일을 작성하기 위한 명령어입니다. 터미널에서 이동 중에 파일을 생성하고 요구사항에 따라 나중에 또는 실시간으로 파일을 채울 수 있습니다. 타임스탬프를 현재 시간으로 변경하는 명령어이기도 합니다.

- cat

  파일의 내용을 간단하게 출력할 때도 사용하지만, cat명령어 이름처럼 **두** **개** **이상의** **파일을** **연결****(concatenate)****해서** **출력**할 때 사용하는 것이 기본입니다. 보통 리다이렉션 기호와 함께 사용하여 파일을 생성하거나 병합을 할 때도 사용됩니다.

- head

  head 명령을 사용하면 터미널에서 직접 파일 또는 파이프 된 데이터의 시작을 볼 수 있습니다. 파일의 앞 부분을 출력합니다. 리눅스에서 오류나 파일 로그를 실시간으로 확인할 때 매우 유용하게 사용됩니다.

- tail

  tail 명령어는 파일의 마지막 행을 기준으로 지정한 행까지의 파일 내용 일부를 출력합니다. 기본 값으로 마지막 10줄을 출력해 줍니다. 리눅스에서 오류나 파일 로그를 실시간으로 확인할 때 매우 유용하게 사용됩니다.

- cp

  cp 명령은 copy의 약어이며, 시스템에서 파일이나 디렉터리를 한 폴더에서 다른 폴더로 복사하도록 지시합니다. 이 깔끔한 명령을 사용하면 터미널에서 바로 여러 파일을 디렉터리로 복사할 수 있습니다.

- mv

  move의 줄임말로 GUI에서 수행하는 절단 작업을 보완합니다. cp와 마찬가지로 mv 명령을 사용하여 하나 또는 여러 파일을 한 위치에서 다른 위치로 이동할 수 있습니다. 

- comm

  comm 명령어를 통해 두개의 파일의 내용을 비교해서 출력할 수 있습니다.

- less

  리눅스에서 파일 내용을 확인하는 명령어들중에 하나로, 파일을 읽어 화면에 출력하는 명령어 이다.

  같은 목적의 명령어 more와 반대되는 의미로 이름이 지어졌다. more는 위에서 아래 방향으로만 출력 되지만, 지나간 내용을 다시 볼 수 없지만, less는 한 번에 보여지는 만큼만 읽어서 출력하기 때문에 대용량의 파일을 열어 볼 때 빠르게 사용 할 수 있다.
   cat 과는 달리 less 명령을 사용하면 터미널 세션을 방해하지 않으면서 파일 내에서 양방향으로 탐색할 수 있습니다.

- ln

   파일의 링크를 생성 할 때 사용(파일 연결 명령어), 하나의 파일에 이름을 두 개 유지 하는 방법을 제공합니다.

  링크 생성을 통해 편리하게 파일과 디렉토리를 관리 할 수 있습니다.

- cmp

  파일 비교 명령어, 모든 종류의 두 개의 파일을 비교하고 그 결과물을 표준 출력에 쓴다. 기본값으로 만약 파일들이 같다면 cmp은 실행되지 않는다. 파일들이 서로 다르다면, 다른 점이 발견된 최초 지점의 바이트와 문자열 숫자를 알려준다.

- dd

  블록 단위로 파일을 복사하거나 파일 변환을 할 수 있는 명령어

- alias

  리눅스(Linux)에서는 자주 사용하는 긴 명령어 조합을 간단하게 **alias(** **별칭** **,** **별명** **)** **로** **등록하여** **사용**할 수 있습니다. 터미널에서 위의 명령어를 입력하면 현재 사용 가능한 단축 명령어를 확인 할 수 있습니다.

 

**네트워크** **관리자에게** **가장** **많이** **사용되는** **리눅스** **명령어**

- wget

  'Web Get'의 약어로 웹 상의 파일을 다운로드 받을 때 사용하는 명령어로 wget은 비 상호작용 네트워크 다운로더 이다. 즉, 네트워크 상에서 데이터를 다운로드하는 기능을 수행한다.

- iptables

  iptable 명령은 시스템 관리자가 특정 호스트 시스템에서 들어오고 나가는 인터넷 트래픽을 제어할 수 있는 터미널 유틸리티를 호출합니다.

  sysadmins는 정기 트래픽을 정의하고 의심스럽거나 신뢰할 수 없는 네트워크 요청을 블랙리스트에 올리는 데 많이 사용하는 Linux 명령어 중 하나입니다.

- traceroute

  traceroute 는 명령어를 실행하는 컴퓨터에서 목적지 서버로 가는 네트워크 경로를 확인해주는 명령어입니다.

- cURL

  curl 이라는 http 메시지를 쉘상에서 요청하여 결과를 확인하는 명령어

- netstat

  netstat 명령어는 네트윅 연결상태를 확인합니다. 현제 접속된 포트, 서비스 상황, ip나 아이디를 확인합니다.

- ping

  ping 명령어는 'Packet INternet Groper'의 약자입니다. 네트워크 상태를 확인하려는 대상(target) 컴퓨터(또는 네트워크 기기)를 향해 일정 크기의 패킷(Packet, 네트워크의 최소 전송 단위)을 전송(ICMP echo request)합니다. 이후 패킷을 받은 대상 컴퓨터는 패킷을 수신하였다는 응답하는 메시지(ICMP echo reply)를 송신합니다. 이를 ping을 입력한 컴퓨터는 응답하는 메시지(ICMP echo reply)를 수신한 후 분석하여 대상 컴퓨터가 작동하는지, 또는 대상 컴퓨터까지 도달하는 네트워크 상태가 어떠한지 파악할 수 있습니다.

  ping 명령어는 TCP/IP 프로토콜 중에 ICMP 프로토콜을 통해 동작합니다. ICMP 프로토콜을 지원하지 않는 기기(흔히 IP 주소를 갖지 않는 일부 스위치, 허브 등)을 대상으로는 ping 명령어를 실행할 수 없습니다.

**Linux** **명령어** **검색** **및** **정규** **표현식**

- find

  파일을 찾을 수 있는데 경로를 지정해서 현재, 대상, 전체 디렉터리 별로 검색이 가능하다. windows에서 검색기능과 동일하다.(파일 사이즈 등 상세정보로 검색이 가능하고 –exec 기능을 활용해서 검색된 파일들만을 대상으로 추가적인 작업(삭제와 같은)또한 가능하다. 또 검색한 파일들의 원하는 정보들을 출력할 수 있다.)

- which

  which는 특정명령어의 위치(경로)를 찾아주는 명령어이다.

- locate

  locate는 다양한 패턴의 파일들을 찾고자 할 때 매우 유용하게 사용되는 명령어이다.

  리눅스 어딘가에 저장되어 있는 파일 목록 DB를 참조해 검색하기 대문에 속도가 매우 빠르다.

- grep

  특정 문자와 matching 되는 항목을 찾을 수 있다. 찾고자 하는 패턴을 입력으로 받아 특정 패턴에 대해 지정된 파일을 검색합니다. 또한 다른 명령어랑 함께 융통성 있는 사용이 가능합니다.

- sed

  원본 파일에 변형을 주지 않고 단지 출력되는 결과를 변화시켜 보여주는 역할을 합니다.

  sed 명령어는 Shell script 를 사용하여 파일을 편집하는 경우에 많이 사용됩니다.

 

**I/O** **및** **소유권을** **다루는** **리눅스** **명령어**

- clear

  clear 명령은 기존 터미널 화면을 지우는데 편리합니다.

- echo

  echo 명령은 터미널 콘솔에 특정 텍스트를 출력할 수 있는 명령어입니다. echo를 입력하고 괄호 안에 일부 텍스트를 입력하면 스스로 확인할 수 있습니다. 이 명령의 흥미로운 점은 출력을 다른 터미널 명령으로 파이프 할 수 있다는 것입니다.

- sort

  사전 순 또는 역순으로 파일을 정렬해야 할 때마다 이 명령을 사용합니다.

- sudo

  현재 계정에서 **root** **권한을** **이용하여** **명령어를** **실행**할 때 사용

- chmod

  chmod는 change mode의 축약어로, 대상 파일과 디렉토리의 사용권한을 변경할 때 사용한다.

- chown

  chwon 명령은 chmod 명령과 매우 유사합니다. 그러나 액세스 권한을 변경하는 대신 사용자가 파일 또는 디렉터리의 소유권을 변경할 수 있습니다. chmod 및 chown 터미널 명령은 모두 루트 권한이 필요합니다.

  파일을 액세스 할 수 있는지 없는지에 대한 권한은 파일의 소유자 및 파일이 속한 그룹뿐만이 아니라, 모드비트라고 하는 **액세스** **비트**의 값과도 관련이 있습니다.

  파일의 소유자 / 파일이 속한 그룹의 멤버 / 기타 라는 세 클래스가 있고, 각 클래스에 대한 읽기, 쓰기, 실행을 의미하는 비트가 정의되어 있습니다.

  "0 0 0 / 0 0 0 / 0 0 0"

  모드비트는 ls -l 의 출력을 통해 확인할 수 있습니다.

  ex)

  ​	-rw------- #모드 600

  ​	-rwxrwxrwx #모드 777

  ​	-rw-rw-rw- #모드 666

- iostat

  iostat 명령어는 CPU와 디스크 처리의 입출력 통계 및 처리량, 대기열 길이 등을 실시간으로 모니터링 할 수 있는 프로그램입니다.

  시스템에 걸리는 부하가 크거나 시스템 성능이 부족할 경우, iostat 명령어를 사용하면 시스템의 전체 성능을 파악하여 문제를 해결할 수 있습니다.

  iostat 명령어는 **/proc/diskstat, /proc/stat, /proc/partitions, /proc/sys** 등의 파일의 내용을 사용하여 정보를 출력합니다.

 

**일상적인** **사용을** **위한** **기타** **명령어**

- man

  man 명령은 manual을 나타냅니다. 이 명령 다음에 다른 명령의 이름은 해당 명령의 매뉴얼 또는 설명서 페이지를 나열합니다. 명령어에 대해서 잘 모를 때 man [명령어]와 같이 입력하여 명령어에 대한 설명을 찾아볼 수 있다.

- tar

  tar 명령은 파일을 아카이브하고 추출하는데 사용됩니다. 파일을 압축하는데 널리 사용되는 명령으로 이러한 작업을 매우 효율적으로 처리할 수 있습니다.

- whatis

  whatis 명령은 사용자가 제공한 간단한 설명으로 데이터베이스 세트를 순회하며 해당 데이터베이스 명령과 일치하는 시스템 명령어를 출력합니다.

 

### 커널이란?

'커널'은 운영체제의 핵심 기능 부로 컴퓨터 자원들을 관리하는 역할을 합니다.

커널은 항상 컴퓨터 자원들만 바라보고 있습니다. 사용자와의 상호작용은 전혀 지원하지 않습니다.

따라서, 사용자와 직접적인 상호작용을 위해서는 시스템 프로그램이 필요하고, 이러한 이유에서 운영체제는 커널 뿐만 아니라 시스템 프로그램을 함께 제공합니다.

대표적인 시스템 프로그램은 쉘(Shell) 이라는 명령어 해석기 입니다. 쉘은 사용자가 컴퓨터에게 전달하는 명령을 해석하는 프로그램으로, 사용자와의 상호작용을 가능케 합니다.

메모리에 항상 상주합니다.

 

   

### 쉘(명령어 해석기)이란?

명령어와 프로그램을 실행할 때 사용하는, 사용자와 커널 사이의 인터페이스.

**쉘의** **기능**

1. 사용자와 커널 사이에서 명령을 해석해 전달하는 **명령어** **해석기** **기능**이 있습니다.

2. 쉘은 자체 내에 **프로그래밍** **기능**이 있어서 프로그램을 작성할 수 있습니다. 쉘 프로그래밍 기능을 이용하면 여러 명령을 사용해 반복적으로 수행하는 작업을 하나의 프로그램으로 제작 할 수 있습니다. 쉘 프로그램을 쉘 스크립트라고 부릅니다.

3. **사용자** **환경** **설정의** **기능** - 초기화 파일 기능을 이용해 사용자의 환경을 설정할 수 있습니다. 로그인 할 때 이 초기화 파일이 실행되서 사용자의 초기 환경이 설정됩니다. 

 

### 쉘프로그래밍

- 쉘을 사용해서 프로그래밍을 할 수 있습니다.

- 서버 작업 자동화같은데에 많이 쓰임

- 기본 명령어를 기반으로 하고, 이에 몇 가지 문법이 추가되는 형태

- 일반적인 프로그래밍 언어와 달리 간단하고, 쉽게 응용 가능

- 쉘 스크립트는 파일로 작성 후, 파일을 실행

- 파일의 첫 라인은 '#! /bin/bash'로 시작

- 쉘 스크립트 파일은 실행 권한이 있어야 한다

- 일반적으로 '파일이름.sh'와 같은 형태로 파일 이름 작성

- 일반적으로 vi, vim같은 편집기 이용해서 작성

 

**주석**

'#'기호로 시작하는 라인은 주석 처리

 

**변수**

- 선언

- 변수명=데이터

- 사이에 띄어쓰기 허용되지 않음

- 사용

- '$변수명'으로 사용

- 해제

- unset 변수명

**리스트** **변수** **(** **배열** **)**

- 선언
  - 변수명=(데이터1 데이터2 데이터3....)

- 사용
  - ${변수명[인덱스번호]}

- 인덱스번호가 '@', '*'이면 모든 데이터

- '#' 이 앞에 붙으면 인수의 개수

**연산자**

- expr : 숫자 계산, 역 작은 따옴표( ` )를 사용해야함

- 연산자 *와 괄호() 앞에는 역슬래시\를 붙여줌

- 연산자와 숫자, 변수, 기호 사이에는 공백을 넣어야 함

**조건**

- 문자1 == 문자2 : 두 문자가 일치

- 문자1 != 문자2 : 두 문자가 불일치

- -z 문자 : 문자가 null이면 참

- -n 문자 : 문자가 null이 아니면 참

- 문자 == 패턴 : 문자열이 패턴과 일치

- 문자 != 패턴 : 문자열이 패턴과 불일치

- 값1 -eq 값2 : 값이 같다

- 값1 -ne 값2 : 값이 같지 않다

- 값1 -lt 값2 : 값1이 값2보다 작다

- 값1 -le 값2 : 값1이 값2보다 작거나 같다

- 값1 -gt 값2 : 값1이 값2보다 크다

- 값1 -ge 값2 : 값1이 값2보다 크거나 같다

- -e 파일명 : 파일이 존재하면 참

- -d 파일명 : 파일이 디렉토리면 참

- -h 파일명 : 심볼릭 링크파일

- -f 파일명 : 파일이 일반파일이면 참

- -r 파일명 : 파일이 읽기 가능이면 참

- -s 파일명 : 파일 크기가 0이 아니면 참

- -u 파일명 : 파일이 set-user-id가 설정되면 참

- -w 파일명 : 파일이 쓰기 가능 상태면 참

- -x 파일명 : 파일이 실행가능 상태면 참

- 조건1 -a 조건2 : AND

- 조건1 -o 조건2 : OR

- 조건1 && 조건2 : 양쪽 다 성립

- 조건1 || 조건2 : 한쪽 또는 양쪽 다 성립

- !조건 : 조건이 성립하지 않음

- true : 언제나 참

- false : 언제나 거짓

**조건문**

- if [ 조건 ]

  then

  ​		명령문

​		else

​			명령문

​		fi

- if [ 조건 ]

  then

  ​	명령문

  fi

- if [ 조건 ]; then 명령문; fi

  [뒤와 ]앞에는 반드시 공백

 

**반복문**

- for 변수 in 변수값1 변수값2 ...

  do

  명령문

  done

- for 변수 in 변수값1 변수값2; do 명령문; done

- while [ 조건문]

  do

  ​	명령문

  done

  

**환경변수**

환경변수란 프롬프트 변경, PATH 변경 등과 같이 셸의 환경을 정의하는 중요한 역할을 수행하는 변수를 말합니다.

셸은 여러가지 환경변수를 사용하는데 이 환경변수는 사용자가 임의로 본인의 의지에 따라 값의 변경이 가능합니다. 하지만 미리 정의된 환경변수의 이름을 변경할 수는 없습니다. 환경변수는 미리 예약된 변수명을 사용합니다.

설정된 환경 변수는 'echo $환경변수이름' 형식으로 명령어를 실행하면 확인할 수 있고, 전체 환경변수의 값은 env 명령으로 확인 가능합니다.

| **변수**     | **내용**                                                     | **변수**     | **내용**                                   |
| ------------ | ------------------------------------------------------------ | ------------ | ------------------------------------------ |
| HOME         | 현재 사용자의 홈 디렉터리                                    | PATH         | 실행 파일을 찾는 디렉터리 경로             |
| LANG         | 기본 지원되는 언어                                           | PWD          | 사용자의 현재 작업 디렉터리                |
| TERM         | 로그인 터미널 타입                                           | SHELL        | 사용자의 로그인 셸                         |
| USER         | 사용자의 이름                                                | DISPLAY      | X윈도에서 프로그램 실행 시 출력되는 창     |
| COLUMNS      | 현재 터미널의 컬럼 수                                        | LINES        | 현재 터미널 라인 수                        |
| PS1          | 1차 명령 프롬프트 변수                                       | PS2          | 2차 프롬프트 변수                          |
| BASH         | bash 셸의 경로                                               | BASH_VERSION | bash 버전                                  |
| HISTFILE     | 히스토리 파일의 절대 경로                                    | HISTSIZE     | 히스토리 파일에 저장되는 명령어(줄)의 개수 |
| HISTFILESIZE | 히스토리 파일의 크기                                         | HOSTNAME     | 시스템의 호스트명                          |
| MAIL         | 도착한 메일이 저장되는 경로                                  | LOGNAME      | 로그인 이름                                |
| TMOUT        | 사용자가 로그인 한 후 일정 시간 동안 작업을 하지 않을 경우에 로그아웃시키는 시간으로 단위는 초 |              |                                            |
| UID          | 사용자의 UID                                                 | OSTYPE       | 운영체제 타입                              |



**Unix 파일 시스템의 주요 디렉토리**

| **디렉토리**   | **목적**                                                     |
| -------------- | ------------------------------------------------------------ |
| /              | 루트 디렉토리                                                |
| /bin(or /sbin) | 시스템을 부팅하는 데 필요한 핵심 실행 파일이 저장된 디렉토리 |
| /dev           | 시스템에 연결된 장치들, 예를들어 터미널, 디스크, 테이프, 모뎀 |
| /etc           | 패스워드, 네트워크 주소와 이름, 시스템 시작 설정 등을 포함하는 시스템 |
| /home          | 사용자 디렉토리                                              |
| /lib           | 프로그램을 위한 다양한 공용 라이브러리들의 홈                |
| /mnt           | 다른 시스템으로부터 익스포트 된 파일 시스템들을 임시로 마운트하고 있는 위치 |
| /proc          | 시스템에서 현재 실행되고 있는 프로세스들의 이미지            |
| /tmp           | 부팅 중 없어질 임시 파일들, 재부팅되면 여기 있는  모든 파일들은 지워진다. |
| /usr           | /usr/bin은 일부 표준 시스템 유틸리티, /usr/man은 맨페이지, /usr/include는 C프로그램 헤더, /usr/sbin은 관리자 실행 프로그램 |
| /var           | 주로 관리자 용인 다양한 파일들을 저장하는 디렉토리. 특히 log파일은 /var/log에 기록 |

- Unix는 부팅시 /etc파일의 설정을 이용해 초기에 필요한 리소스와 데몬 등을 로딩한다.

- 부팅시 시스템의 설정을 하기 위한 스크립트는 /etc/init.d와 /etc/rc.d이다.

- 이 설정 파일들을 이용해 시스템 로딩을 하는 프로세스가 init이다.

- init은 System Logging을 위한 작업, 시스템을 위한 작업 스케쥴링, 네트워크 설정 등을 포함하는 스크립트를 보고 필요한 작업을 진행한다.

 

 